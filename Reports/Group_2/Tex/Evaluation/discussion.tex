\chapter{Discussion}

\section{Evaluation of Development Method}
In this section, we evaluate on the development method described in \autoref{sec:dev_meth}.\\

	\paragraph{Agile Development}
In the beginning of the project we worked towards the vision described in \autoref{sec:vision}. Because other parts of the multi project changed, we had to alter the focus of our project. These changes occurred when we had begun developing, and since we used an agile development method, it was possible for us to change direction instead of starting all over.

	\paragraph{Meetings}
The meetings have been useful, since the individual projects changed when the development begun, and these changes was presented at the meetings. This helped the groups adapt their project to fit in the multi project.

	\paragraph{Sprint Length}
Since meetings were only planned in the beginning and end of each sprint, and these meetings were used to present backlogs and discuss overlapping concerns, it was important that the sprint length was short (7-14 days). This was an appropriate length, because it was possible to stay updated on the progress of the multi project, and adapt the individual project to it.

	\paragraph{Product Owner}
Since we had no product owner, we did not have one person to manage the multi project, and therefore all decisions were made democratically by the multi project groups. This lead to several time consuming discussions of minor details regarding the project.

%--------------------------
\section{Development Tools}
As described in \autoref{cha:development_tools}, we have used pair programming and refactoring. We evaluated on our use of these methods as part of a mini project in the course \textit{Software Engineering}, this evaluation is included here.

\subsection{Pair programming}
We did some pair programming, but we were unable to do all programming in pairs. Since we are three persons in the group, we would either have to work three around one computer, or exclude one person from the pair programming. We chose to exclude one person from the pair programming, also because it would be a waste of resources to work in groups of three since the efficiency does not match the cost, when adding the third person.

One of the downsides of the pair programming technique is that we have been unable to work in pairs outside the university, i.e. when two group members are doing pair programming on a specific part of the code, and one of them got sick, the programming would be continued by only one group member, the third group member would join the programming and thereby pause the tasks he was doing, or the programming of the specific part of code would be paused until both group members would be gathered again.

The code written in pairs, is of higher quality than the code written before we implemented the pair programming technique, and the higher quality code is more readable, and thereby has no need for refactoring. We therefore believe that the use of the pair programming technique has been beneficial. This technique could be useful in our future careers.

\subsection{Refactoring}
There are two main reasons for the need for the code to have high readability and understandability. One reason is that the project will be handed over to the students of next year for further development, so to help them we strive to write understandable code. The other reason is that we are three persons in the group, and we have not all been included in developing every part of the program, so with understandable code it is easier for the other group members to understand the parts they did not participate in writing.

Some of the refactoring we have done is renaming variables and objects to match the content of them. Also all private variables and objects has been refactored to always start with either "m" or "_".

The use of this technique has helped ourselves to better understand the code, and we believe that when the project is passed on to the next project groups, it will be easier to familiarize themselves with it. We have learned that refactoring is very useful when several people are developing on the same product, and since we are very likely to work in groups later in our careers, we will probably use this technique again.