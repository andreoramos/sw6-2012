We have with varied success implemented most of the techniques and tools which have affected out project in many interesting ways.

\subsection*{Scrum}
Using Scrum as our development method have not only been a success. Working in the set sprints towards temporal goals
have given us better ability to keep track of the project from start to finish, rather than ``winging'' it as we have done in previous projects.
It has enabled us to start earlier on implementation on the project and have a better workflow.
That said, there is quiet a few of the smaller elements in Scrum that we have not fully implemented or even used at all.
One of these elements is the daily standup meeting, which have been kind of slacking on this, since we all the time had a pretty idea of where we
were and where we were heading, which made the standup meetings kind of redundant. However, since we did not have a tradition for the standup meetings, it probably also led us to slack
a bit on the daily burndown, so far in this project we have not updated our burndown charts for a full sprint.
 
\subsection*{Agile stuff - Pair programming, TDD and Continous intergration}
Our project group has for the most part been split into two working teams, where one of these teams, have been working individually and the other team has seen limited pair programming.
It has been used in early phases of development to get both of the team members up to speed on the technology used, and efterwards they worked individually.
Test driven development has not been used very much, ad hoc testing classes has been written to check up on the system, but any kind of automated unit testing or testing mantra(like writing test up front etc)
has not been used. Testing in development has primary been used to verify that the system works as intended, at least in a specific configuration.
Continous intergration has been used, but not in the sense that we had a some kind of working system after each sprint, we actually went four sprints before the internal server software was in a shape
that could be characterized as working. This is most likely because of a limited knowledge of the problem domain and experience with implementing this kind of software.

\subsection*{Tools - UML,Mockups, eclipse, subversion and design patterns}
We probably had the most success implementing our tools in the project, this probably because many the tools we have already used in previous projects.
UML diagrams have not really been used a lot in this stage of the project, only a limited amount for some an overall design, the idea is to use it for documentation.
We have used mockups for the webinterface part of our project, as a way of creating an early design idea and bringing it to our customers.
They provided us with some feedback to improve our design. Our mockups will also be a part of our project report for documentation purposes.
We have used a few design patterns in our project, nothing really fancy, but it has helped us out of some snags, especially with socket connections from our clients.
Also our server is implemented on a produceer/consumer style pattern which helped us relativaly quick to produce a simple que based server, leaving us time to focus on the inner workings.
Using eclipse and subversion in our project has brought almost nothing new for us, these tools have been well intergrated in all our projects so far. Having a functional IDE like eclipse
help speed up many tedious jobs and make our work process more effective. Subversion is there to save us a lot of hassle with exchanging documents and working files while also giving us a central recovery
and backup utility.
